---
title: "Report and Figures"
author: "Phil Chodrow"
date: "June 15, 2016"
output: 
  html_document:
    toc: true
    toc_float: true
    theme: simplex
---

```{r warning = FALSE, message = FALSE, echo = FALSE}
knitr::opts_chunk$set(echo = FALSE)

library(compx)
library(ggplot2)
library(rgdal)
library(ggmap)
library(dplyr)
library(gridExtra)
library(readr)
library(ggrepel)
library(DT)
library(caTools)
library(tidyr)
library(maptools)
library(grid)
library(stargazer)
library(magrittr)



columns = c('Asian', 'Black', 'Other', 'White', 'Hispanic')

```

# Purpose 

The purpose of this document is to generate the figures used in this project. It is not a complete technical report; see the full writeup if that's what you're looking for. 

# Methods

## Motivation

```{r, fig.height=3}
checkerboard_illustration()
ggsave('figs/checkerboard.png', width = 4, height = 1.5)
```

## Methodological illustration
```{r, warning = FALSE, message = FALSE}
columns <- c('Black', 'Hispanic', 'Asian', 'White', 'Other')
method_illustration <- function(city, vmax){
	hexgrid <- readOGR(dsn = paste0('throughput/grids/',city), layer = 'geo', verbose = FALSE)
	df <- hexgrid@data
	df <- df %>% mutate(id = as.character(row_number()))
	hexgrid <- fortify(hexgrid) %>%
		left_join(df, by = c('id' = 'id'))
	bbox <- c(min(hexgrid$long), min(hexgrid$lat), max(hexgrid$long), max(hexgrid$lat))
	
	# squarify
	max_range <- max(bbox[3] - bbox[1], bbox[4] - bbox[2])
	
	long_mid <- (bbox[3] + bbox[1]) / 2
	lat_mid  <- (bbox[2] + bbox[4]) / 2
	
	bbox[1] <- long_mid - max_range / 2
	bbox[3] <- long_mid + max_range / 2
	bbox[2] <- lat_mid  - max_range / 2
	bbox[4] <- lat_mid  + max_range / 2
	
	map <- get_map(location = bbox, maptype = 'terrain-background')

	p <- ggmap(map,darken = .5)
	p <- p +
		geom_polygon(data = hexgrid, aes(x = long, y = lat, group = group, fill = info), alpha = .8) +
		scale_fill_continuous(low = 'white', high = 'steelblue', name= expression(J[Y](x)), limits = c(0, vmax), breaks = c(0,2,4,6)) +
		theme(axis.ticks = element_blank(),
			  axis.text.x = element_blank(),
			  axis.text.y = element_blank()) +
		xlab('') +
		ylab('') +
		theme(legend.justification=c(.8,0),
			  legend.position=c(1,0),
			  legend.background = element_rect(fill = alpha('blue', 0)),
			  legend.title = element_text(colour="white"),
			  legend.text = element_text(colour="white"),
			  legend.key.size = unit(2, "mm"),
			  legend.text = element_text(size = rel(.1))) +
		ggtitle(paste0('Local Information in ', city, '\nJ(X,Y) = ', round(weighted.mean(df$info, df$density), 2)))
	p
}




first <- method_illustration('Detroit', vmax = 6)
second <- method_illustration('Philadelphia', vmax = 6)

gA <- ggplotGrob(first)
gB <- ggplotGrob(second)
g <- gridExtra::cbind.gtable(gA, gB, size = "max")

grid.draw(g)

ggsave('figs/method_illustration.png', g, width = 8, height = 5)

```

```{r additive_decomposability}

expand.grid(x = 1:8, y = 1:8) %>% 
	mutate(`(e)` = .5,
		   `(e)` = ifelse(x %in% 2:4 & y %in% 2:7, 0, `(e)`),
		   `(e)` = ifelse(x %in% 5:7 & y %in% 2:7, 1, `(e)`),
		   `(f)` = .5) %>%
	gather(key = model, value = p, -x, -y) %>%
	ggplot(aes(x = x, y = y)) +
		theme_minimal() +
		theme(axis.ticks = element_blank(),
			  axis.text.x = element_blank(),
			  axis.text.y = element_blank(),
			  panel.background = element_rect(),
			  panel.grid.major = element_line(size = 0),
			  panel.grid.minor = element_line(size = 0),
			  plot.margin=unit(c(0,0,0,0),"mm")) +
		geom_tile(aes(fill = p)) +
		scale_fill_continuous(low = 'white', high = 'black ', limits=c(0,1)) +
		facet_grid(~model) +
		xlab('') +
		ylab('') +
		guides(fill=FALSE)

ggsave('figs/decomposability.png', width = 2.5, height = 1.5)

```



#  Mean Local Information

```{r}

cache <- read_csv('throughput/info_cache.csv')

```

## Relationship to mutual information

```{r}
highlight <- cache %>%
	filter(I_XY > .4)

cache %>%
	ggplot(aes(x = I_XY, y = weighted_J)) + 
	geom_point(color = 'grey') + 
	theme_minimal() + 
	ylab(expression(J(X,Y))) + 
	xlab(expression(I(X,Y))) + 
	ggtitle('Mutual information and mean local information in major US cities') +
	geom_point(data = highlight, color = 'firebrick') + 
	geom_text_repel(data = highlight, aes(label = city))

ggsave('figs/mutual_fisher.png', width = 8, height = 4)

```


## Relationship to population density
```{r}
lm_eqn <- function(df){
	m <- lm(weighted_J ~ log(density), data = df) 
	eq <- substitute(italic(y) == a + b %.% ~'log' ~italic(rho)*","~~italic(r)^2~"="~r2, 
					 list(a = format(coef(m)[1], digits = 2), 
					 	 b = format(coef(m)[2], digits = 2), 
					 	 r2 = format(summary(m)$adj.r.squared, digits = 3)))
	as.character(as.expression(eq))                 
}

cache %>% 
	# filter(!grepl('Los Angeles', city)) %>%
	ggplot(aes(x = density, y = weighted_J)) +
	geom_smooth(method = 'lm', se = FALSE, color = 'black', size = .4) +
	annotate('text', x = 3000, y = .2, label = lm_eqn(cache), parse = T) + 
	geom_point(color = 'grey') + 
	geom_point(color = 'firebrick', data = highlight) + 
	geom_text_repel(aes(label = city), size = 3, data = highlight) +
	scale_x_continuous(trans = 'log10') +
	# scale_y_continuous(trans = 'log10') +
	theme_minimal() +
	xlab(expression(rho~(population/km^{2}))) +
	ylab(expression(J(X,Y))) +
	annotation_logticks(size = .1, sides = 'b') +
	ggtitle('Dependence of spatial complexity on population density')

ggsave('figs/density_fisher.png', width = 8, height = 4)
```


## Raw measures

```{r}
# Table --------

tab <- cache %>% 
	select(area, population, H_Y, I_XY, J = weighted_J) %>% 
	mutate(Density = population / area) %>% 
	round(2) %>%
	cbind(cache$city, .) %>%
	rename(City = `cache$city`, 
		   `Area` = area,
		   Population = population,
		   HY = H_Y,
		   IXY = I_XY) %>%
	arrange(desc(Density)) %>% 
	select(City, `Area`, Population, Density, HY, IXY, J)

tab %>% write_csv('figs/table.csv')

tab %>% select(City, HY, IXY, J) %>% 
	filter(City %in% c( 'Albuquerque', 'Detroit', 'Philadelphia')) %>% 
	arrange(City) %>%
	mutate(HY = sprintf("%.2f", HY),
		   IXY = sprintf("%.2f", IXY),
		   J = sprintf("%.2f", J)) %>% 
	write_csv('figs/mini_table.csv')


tab$Population <- format(tab$Population, big.mark=",", scientific=FALSE)
tab$Area <- format(tab$Area, big.mark=",", scientific=FALSE)
tab$Density <- format(tab$Density, big.mark=",", scientific=FALSE)

datatable(tab, options = list(pageLength = 10), rownames = FALSE,
		  caption = 'Table 1: This is a simple caption for the table.')

```

# Clusterings

```{r}

loss_curves <- read_csv('throughput/loss_curves.csv') %>% 
	group_by(city) %>% 
	arrange(desc(I_XY)) %>% 
	mutate(I_XY = max(I_XY) - I_XY,
		   nclust = row_number())
	
info_summary <- read_csv('throughput/info_cache.csv')

join_cols <- c('area', 'population', 'density', 'H_X', 'H_Y', 'local.H_Y', 'weighted_J', 'city')
loss_curves <- loss_curves %>% left_join(info_summary[,join_cols])

```

## Example clustering

```{r}

cluster_map <- function(city, nclusters = 10){
	tracts <- readOGR(dsn = paste0('data/cities/',city), layer = 'geo', verbose = FALSE)
	tracts <- tracts[sum(tracts@data[,columns]) != 0,]
	clusters <- readRDS(paste0('throughput/clusterings/', city))
	
	tracts@data$cluster <- cutree(clusters,nclusters)
	overlay <- unionSpatialPolygons(tracts, IDs = tracts@data$cluster)
	
	tracts@data <- tracts@data %>%
		mutate(id = as.character(row_number() - 1))
	
	to_plot <- fortify(tracts)
	to_overlay <- fortify(overlay)
	
	to_plot <- to_plot %>% 
		left_join(tracts@data[,c('id', 'cluster')])
	
	to_plot %>% 
		ggplot() +
		geom_polygon(aes(x = long, y = lat, group = group, fill = factor(cluster))) + 
		scale_fill_brewer(palette = 'Set3', name = NULL, guide = guide_legend(nrow = 1), labels = LETTERS[1:nclusters]) + 
		# ggtitle(paste0('Example clustering for ', city)) + 
		theme_minimal() +
		theme(axis.ticks = element_blank(),
			  axis.text = element_blank(),
			  axis.title = element_blank(),
			  panel.grid = element_blank(),
			  legend.position = 'bottom') +
		geom_polygon(aes(x = long, y= lat, group = group), data = to_overlay, fill = NA, size = .3, color = 'black')

}

cluster_map('Detroit', nclusters = 6)

ggsave('figs/example_cluster_map.png',  width = 8, height = 4)

```

```{r fig.cap='Example clusterings for 4 major cities.'}

make_cluster_groups <- function(city, nclusters = 10){
	tracts <- readOGR(dsn = paste0('data/cities/',city), layer = 'geo', verbose = FALSE)
	tracts <- tracts[sum(tracts@data[,columns]) != 0,]
	clusters <- readRDS(paste0('throughput/clusterings/', city))
	
	tracts@data$cluster <- cutree(clusters,nclusters)
	
	I <- mutual_info(tracts@data[,c(columns, 'cluster')],group_col = 'cluster')
	
	tracts@data <- tracts@data %>%
		mutate(id = as.character(row_number() - 1))
	
	tracts@data[,c(columns, 'cluster')] %>% 
		group_by(cluster) %>% 
		summarise_each(funs(sum)) %>%
		gather(key = race, value = n, -cluster) %>% 
		mutate(n = n / sum(n)) %>% 
		group_by(cluster) %>% 
		filter(sum(n) > .01) %>% 
		ungroup() %>% 
		spread(key = race, value = n, fill = 0) %>% 
		# arrange(desc(White)) %>% 
		mutate(cluster = factor(LETTERS[1:nrow(.)])) %>%  
		gather(key = race, value = p, -cluster) %>% 
		mutate(city = city,
			   I = I,
			   title = paste0(city, ": I(C,Y) = ", round(I,2)))
		
}

nclusters = 5
df <- rbind(make_cluster_groups('Detroit', 3), 
	  make_cluster_groups('Boston', 5),
	  make_cluster_groups('Chicago', 4),
	  make_cluster_groups('Atlanta', 2)) 

df %>% 
	ggplot(aes(y = race, x = cluster, fill = p)) + 
	geom_tile(color = 'black') + 
	geom_text(aes(
		label = ifelse(p < 0.005, "", 100 * round(p,2)))) +
	theme_minimal() + 
	theme(axis.ticks.x = element_blank(),
		  axis.title = element_blank(),
		  legend.position="bottom",
		  legend.title = element_blank()) +
	scale_fill_continuous(low = 'white', high = 'steelblue', limits = c(0, NA), guide = FALSE) +
	ggtitle(paste0('Example clusters')) + 
	facet_wrap(~title, ncol = 2)

ggsave('figs/example_clusters.png')

```

```{r}
make_cluster_groups('Detroit', 6) %>% 
	mutate(race = factor(race, levels = c('Other', 'Asian', 'Hispanic', 'Black', 'White'))) %>% 
	ggplot(aes(y = race, x = cluster, fill = p)) + 
	geom_tile(color = 'black') + 
	geom_text(aes(
		label = ifelse(p < 0.005, "", 100 * round(p,2)))) +
	theme_minimal() + 
	theme(axis.ticks.x = element_blank(),
		  axis.title = element_blank(),
		  legend.position="bottom",
		  legend.title = element_blank()) +
	scale_fill_continuous(low = 'white', high = 'steelblue', limits = c(0, NA), guide = FALSE) 
	# ggtitle(paste0('Example clusters')) 

ggsave('figs/example_clusters_detailed.png', width = 4, height = 2)

```

Follow up on Detroit by area (percent of area occupied by each cluster.)

```{r}
city = 'Detroit'
nclusters = 6

tracts <- readOGR(dsn = paste0('data/cities/',city), layer = 'geo', verbose = FALSE)
tracts <- tracts[sum(tracts@data[,columns]) != 0,]
clusters <- readRDS(paste0('throughput/clusterings/', city))

tracts@data$cluster <- cutree(clusters,nclusters)
overlay <- unionSpatialPolygons(tracts, IDs = tracts@data$cluster)
plot(overlay)

sapply(slot(overlay, "polygons"), slot, "area")  %>% simplex_normalize()


```



## Loss curves

```{r}
end_points <- loss_curves %>%
	group_by(city) %>%
	filter(nclust == max(nclust)) %>% 
	filter(weighted_J > 1.25 | weighted_J < .75)

loss_curves %>% 
	ggplot() +
	aes(x = nclust, y = I_XY, group = city) +
	geom_path(aes(color = weighted_J)) +
	# geom_point(aes(color = weighted_J), size = .3) +
	scale_x_continuous(trans = 'log10', limits = c(1, max(loss_curves$nclust) + 1000)) +
	# scale_y_continuous(trans = 'log10') +
	geom_text(aes(x = nclust, y = I_XY, label = city, hjust = -.2), data = end_points) +
	theme_minimal() +
	scale_color_continuous(low = 'white', high = 'firebrick',limits = c(0,2)) +
	annotation_logticks(size = .1, sides = 'b') +
	ggtitle('Loss curves for spatially-constrained information-theoretic clustering')

ggsave('figs/loss_curves.png', width = 8, height = 4)

```

```{r}
end_points <- loss_curves %>%
	group_by(city) %>%
	filter(nclust == max(nclust))

loss_curves %>% 
	group_by(city) %>% 
	mutate(I_max = max(I_XY)) %>% 
	ggplot() +
	aes(x = nclust, y = I_XY, group = city) +
	geom_path(aes(color = I_max)) +
	# geom_point(aes(color = weighted_J), size = .3) +
	scale_x_continuous(trans = 'log10', limits = c(1, max(loss_curves$nclust) + 1000)) +
	# scale_y_continuous(trans = 'log10') +
	geom_text(aes(x = nclust, y = I_XY, label = city, hjust = -.2), data = end_points) +
	theme_minimal() +
	annotation_logticks(size = .1, sides = 'b') +
	ggtitle('Loss curves for spatially-constrained information-theoretic clustering')


```



## Normalized loss curves:

```{r}


loss_curves %>%
	group_by(city) %>%
	mutate(I_XY = I_XY / max(I_XY)) %>%
	mutate(nclust = nclust / max(nclust)) %>%
	# filter(nclust < 100) %>%
	ggplot() +
	aes(x = nclust, y = I_XY, color = weighted_J, group = city) +
	geom_path() +
	scale_x_continuous(trans = 'log10') +
	scale_y_continuous(trans = 'log10') +
	theme_minimal() +
	scale_color_continuous(low = 'white', high = 'firebrick',limits = c(0,2)) +
	annotation_logticks(size = .1, sides = 'b') + 
	ggtitle('Normalized loss curves for spatially-constrained information-theoretic clustering')

ggsave('figs/normed_loss_curves.png', width = 8, height = 4)
```

## Evaluating loss curves

### AUC illustration

```{r}


cities <- c('Atlanta','Boston')

compute_AUC <- function(loss_curves, adjust_thresh = 0){
	loss_curves %>% 
		group_by(city) %>%
		mutate(exclude = (nclust != 1) & (cummax(I_XY - lag(I_XY,default = 0)) < adjust_thresh) & (nclust < 10)) %>% 
		filter(!exclude) %>%
		mutate(nclust = row_number()) %>% 
		mutate(dx = log(nclust / (nclust - 1))) %>%
		filter(nclust > 1) %>%
		group_by(city) %>%
		arrange(nclust) %>%
		summarise(corner = max(I_XY) * log(max(nclust)),
				  area = trapz(nclust, I_XY / nclust)) %>%
		mutate(AUC = area / corner) %>%
		arrange(desc(AUC)) 
}






summary <- compute_AUC(loss_curves, adjust_thresh = 0) 

summary <- summary %>% left_join(cache, by = c('city' = 'city'))

# %>%
# 	left_join(info_summary[,c('city', 'weighted_J', 'I_XY')]) %>%
# 	filter(I_XY > 0) 

sub_summary <- summary %>% filter(city %in% cities)

sub_curves <- loss_curves %>%
	filter(city %in% cities) 

end_points <- sub_curves %>%
	group_by(city) %>%
	filter(nclust == max(nclust))

rects <- sub_curves %>% group_by(city) %>% 
	summarise(xmin = 1, ymin = 0, xmax = max(nclust), ymax = max(I_XY))

filled <- sub_curves[,c('nclust','I_XY', 'city')]

corner <- filled %>% group_by(city) %>%
	summarise(nclust = max(nclust),
			  I_XY = 0)

filled <- rbind(corner, filled) %>%
	arrange(city, nclust, desc(I_XY))

sub_curves %>% 
	ggplot() +
	geom_path(aes(x = nclust, y = I_XY, group = city, color = city)) +
	scale_x_continuous(trans = 'log10', limit = c(1, NA)) +
	scale_y_continuous(limit = c(0,max(sub_curves$I_XY))) +
	theme_minimal() +
	annotation_logticks(size = .1, sides = 'b', scaled = T) + 
	geom_rect(data = rects, aes(xmin = xmin,
								ymin = ymin,
								xmax = xmax,
								ymax = ymax,
								group = city),
			  color = 'grey',
			  alpha = 0) +
	# geom_text(aes(x = nclust, y = I_XY, label = city, hjust = -.2), data = end_points) + 
	geom_polygon(aes(nclust, I_XY, fill = city), data = filled, alpha = .2) + 
	geom_text(aes(x = 50, y = .2, label = paste('AUC = ', round(AUC,2))), data = sub_summary) + 
	geom_text(aes(x = 50, y = .1, label = paste('J(X,Y) = ', round(weighted_J,2))), data = sub_summary) +
	facet_wrap(~city) + 
	scale_fill_discrete(guide = F) + 
	scale_color_discrete(guide = F) + 
	xlab('Number of clusters') + 
	ylab('I(C,Y)') + 
	ggtitle('AUC as Clustering Evaluation')



ggsave('figs/AUC_illustration.png', width = 8, height = 4)
```


```{r}

# dippy point that doesn't seem to be true here: if you don't have any excluded points on your curve, your AUC should be the same. 


adjusted_summary <- compute_AUC(loss_curves, adjust_thresh = .005) %>%
	select(city, adj_AUC = AUC)

summary <- summary %>% 
	left_join(adjusted_summary)
```

```{r}

summary %>% 
	ggplot() +
	aes(x = AUC, y = adj_AUC) +
	geom_point() + 
	geom_text_repel(aes(label = city)) + 
	geom_abline(slope = 1, intercept = 0)

```


## Raw clustering performance 

```{r}

summary[,c('I_XY', 'weighted_J', 'AUC', 'adj_AUC')] %>% 
	round(2) %>% 
	cbind(summary$city) %>% 
	select(city = `summary$city`, I_XY, weighted_J, AUC, adj_AUC) %>%
	datatable(options = list(pageLength = 10), rownames = FALSE,
		  caption = 'Table 1: This is a simple caption for the table.')
```

# Relationship to information measures 

```{r}

highlight <- summary %>% 
	filter(I_XY >= 0)

summary %>%
	ggplot() +
	aes(x = I_XY, y = AUC) +
	geom_point(aes(color = weighted_J)) +
	geom_smooth(color = 'grey', se = F) +
	geom_text_repel(aes(label = city), data = highlight) + 
	theme_minimal() + 
	ggtitle('Clustering performance and mutual information') +
	scale_color_continuous(low = 'white', high = 'firebrick',limits = c(0,2)) +
	xlab('I(X,Y)') + 
	ylab('AUC')

ggsave('figs/info_performance.png', width = 8, height = 4)

```

```{r}
highlight <- summary %>% filter(I_XY > .4)

summary %>%
	ggplot() +
	aes(x = I_XY, y = adj_AUC) +
	geom_point(aes(color = weighted_J)) +
	geom_smooth(color = 'grey', se = F) +
	geom_text_repel(aes(label = city), data = highlight) + 
	theme_minimal() + 
	ggtitle('Clustering performance and mutual information') +
	xlab('I(X,Y)') + 
	ylab('AUC (geographically adjusted)') + 
	scale_color_continuous(low = 'white', high = 'firebrick',limits = c(0,.2), name = "J(X,Y)", guide = guide_colorbar(direction = 'horizontal')) +
	theme(legend.justification=c(1.5,0),
			  legend.position=c(1,0))

ggsave('figs/info_performance_adjed.png', width = 8, height = 4)

```

### Basic linear regression 

```{r}
summary %>% mutate(AUC = adj_AUC / max(adj_AUC),
		   `I(X,Y)` = I_XY / max(I_XY),
		   `J(X,Y)` = weighted_J / max(weighted_J),
		   `H(Y)` = H_Y / max(H_Y)) %>%
	filter(I_XY > 0) %>%
	lm(AUC ~ `I(X,Y)` + `J(X,Y)`, data = .) %>%
	stargazer(flip = T, 
			  # table.layout = '#tn', 
			  style = 'all2',
			  ci = T,covariate.labels = c('$I(X,Y)$','$J(X,Y)$', 'Intercept'),
			  table.layout = '-=-!=!dtas',
			  float = F) %>% 
	write(file = 'figs/adjusted_regression.txt')
```


# Session info
```{r}
sessionInfo()
```
